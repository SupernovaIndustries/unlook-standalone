#pragma once

#include "unlook/stereo/DepthProcessor.hpp"
#include "unlook/calibration/CalibrationManager.hpp"
#include <opencv2/core.hpp>
#include <opencv2/imgproc.hpp>
#include <memory>
#include <string>
#include <functional>
#include <chrono>

// Forward declarations for Open3D types
#ifdef OPEN3D_ENABLED
namespace open3d {
namespace geometry {
class PointCloud;
}
}
#endif

namespace unlook {
namespace stereo {

/**
 * @brief Point cloud generation configuration
 *
 * Configures depth map to point cloud conversion with filtering options.
 * Optimized for industrial precision (0.005mm target) on ARM64 hardware.
 */
struct PointCloudGenerationConfig {
    // Depth filtering (pre-processing before point cloud generation)
    bool filterDepthBeforeConversion = true;
    float minDepthMm = 200.0f;              // Minimum valid depth (3x baseline)
    float maxDepthMm = 3500.0f;             // Maximum valid depth
    float maxDepthChange = 50.0f;           // Maximum depth change between neighbors (mm)

    // Point cloud generation
    bool skipInvalidPoints = true;          // Skip NaN/Inf depth values
    bool computeNormals = true;             // Estimate surface normals
    int normalNeighborRadius = 5;           // Radius for normal estimation (pixels)

    // Color mapping
    bool enableColorMapping = true;         // Map RGB values from color image
    cv::Vec3b defaultColor = {255, 255, 255}; // Default color if no color image

    // Statistical outlier removal (Open3D-based if available)
    bool enableStatisticalFiltering = true;
    int statisticalNeighbors = 20;          // K-nearest neighbors for outlier detection
    double statisticalStdRatio = 2.0;       // Standard deviation ratio threshold

    // Radius outlier removal
    bool enableRadiusFiltering = false;
    double radiusThresholdMm = 10.0;        // Search radius in mm
    int minRadiusNeighbors = 5;             // Minimum neighbors within radius

    // Voxel downsampling (for performance)
    bool enableVoxelDownsampling = false;
    double voxelSizeMm = 1.0;               // Voxel size in mm

    // Plane removal (remove background plane)
    bool enablePlaneRemoval = false;
    double planeDistanceThresholdMm = 5.0;  // RANSAC distance threshold
    int planeRansacIterations = 1000;
    int planeMinPoints = 100;

    // Performance
    bool useParallelProcessing = true;      // Enable OpenMP/TBB parallelization
    int numThreads = 4;                     // Number of threads (0=auto)

    bool validate() const;
    std::string toString() const;
};

/**
 * @brief Point cloud quality metrics
 */
struct PointCloudQualityMetrics {
    size_t totalPoints = 0;
    size_t validPoints = 0;
    double validRatio = 0.0;

    // Density metrics
    double meanPointDensity = 0.0;          // Points per cubic mm
    double pointSpacing = 0.0;              // Average nearest neighbor distance (mm)

    // Noise metrics
    double noiseLevel = 0.0;                // Standard deviation of local planarity
    size_t outlierCount = 0;
    double outlierRatio = 0.0;

    // Coverage metrics
    double coveragePercentage = 0.0;        // Percentage of depth map with valid points
    cv::Rect boundingBox2D;                 // 2D bounding box in image space

    // 3D extents
    cv::Vec3f minBounds = {FLT_MAX, FLT_MAX, FLT_MAX};
    cv::Vec3f maxBounds = {-FLT_MAX, -FLT_MAX, -FLT_MAX};
    cv::Vec3f centroid = {0, 0, 0};

    // Processing time
    std::chrono::milliseconds conversionTime{0};
    std::chrono::milliseconds filteringTime{0};
    std::chrono::milliseconds totalTime{0};

    std::string toString() const;
};

/**
 * @brief PLY export configuration
 */
struct PLYExportConfig {
    enum class Format {
        ASCII,          // Human-readable ASCII format
        BINARY_LE,      // Binary little-endian (standard)
        BINARY_BE       // Binary big-endian
    };

    Format format = Format::BINARY_LE;

    // Data fields to export
    bool includeNormals = true;
    bool includeColors = true;
    bool includeConfidence = false;         // Per-point confidence values

    // Metadata
    std::string comment = "Generated by Unlook 3D Scanner";
    std::string timestamp;                  // Auto-filled if empty
    double precisionMm = 0.005;             // Target precision metadata
    std::string calibrationFile;            // Calibration file reference

    // Manufacturing precision metadata
    bool includeManufacturingMetadata = false;
    std::string partName;
    std::string scanOperator;
    std::string material;

    std::string getFileExtension() const { return ".ply"; }
    bool validate() const;
    std::string toString() const;
};

/**
 * @brief High-performance point cloud generator
 *
 * Converts depth maps to 3D point clouds with advanced filtering,
 * normal estimation, and multi-format export. Optimized for ARM64
 * and industrial precision applications.
 *
 * Processing Pipeline:
 * 1. Depth map validation and filtering
 * 2. 3D point generation using calibration Q matrix
 * 3. Color mapping from RGB image
 * 4. Statistical outlier removal (Open3D-based)
 * 5. Normal vector estimation
 * 6. Quality metric computation
 * 7. Export to PLY/PCD/OBJ formats
 *
 * Performance Targets:
 * - VGA (640x480): < 50ms conversion
 * - HD (1280x720): < 150ms conversion
 * - Memory: < 500MB for 1M points
 */
class PointCloudGenerator {
public:
    PointCloudGenerator();
    ~PointCloudGenerator();

    /**
     * @brief Initialize with calibration manager
     * @param calibrationManager Shared pointer to calibration manager
     * @return true if initialization successful
     */
    bool initialize(std::shared_ptr<calibration::CalibrationManager> calibrationManager);

    /**
     * @brief Generate point cloud from depth map
     * @param depthMap Input depth map (CV_32F, millimeters)
     * @param colorImage Optional color image (CV_8UC3, same size as depth)
     * @param pointCloud Output point cloud
     * @param config Generation configuration
     * @return true if generation successful
     */
    bool generatePointCloud(const cv::Mat& depthMap,
                           const cv::Mat& colorImage,
                           PointCloud& pointCloud,
                           const PointCloudGenerationConfig& config = {});

    /**
     * @brief Generate point cloud with quality metrics
     * @param depthMap Input depth map
     * @param colorImage Optional color image
     * @param pointCloud Output point cloud
     * @param metrics Output quality metrics
     * @param config Generation configuration
     * @return true if generation successful
     */
    bool generatePointCloudWithMetrics(const cv::Mat& depthMap,
                                       const cv::Mat& colorImage,
                                       PointCloud& pointCloud,
                                       PointCloudQualityMetrics& metrics,
                                       const PointCloudGenerationConfig& config = {});

#ifdef OPEN3D_ENABLED
    /**
     * @brief Generate Open3D point cloud with advanced filtering
     * @param depthMap Input depth map
     * @param colorImage Optional color image
     * @param config Generation configuration
     * @return Open3D point cloud (nullptr if failed)
     */
    std::shared_ptr<open3d::geometry::PointCloud> generateOpen3DPointCloud(
        const cv::Mat& depthMap,
        const cv::Mat& colorImage,
        const PointCloudGenerationConfig& config = {});
#endif

    /**
     * @brief Apply advanced filtering pipeline to point cloud
     * @param pointCloud Point cloud to filter (modified in-place)
     * @param config Configuration with filter parameters
     * @return true if filtering successful
     */
    bool applyFilteringPipeline(PointCloud& pointCloud,
                               const PointCloudGenerationConfig& config);

    /**
     * @brief Compute surface normals for point cloud
     * @param pointCloud Point cloud (must have valid 3D points)
     * @param neighborRadius Radius for neighbor search (pixels)
     * @return true if normal estimation successful
     */
    bool estimateNormals(PointCloud& pointCloud, int neighborRadius = 5);

    /**
     * @brief Assess point cloud quality metrics
     * @param pointCloud Input point cloud
     * @param metrics Output quality metrics
     * @return true if assessment successful
     */
    bool assessQuality(const PointCloud& pointCloud,
                      PointCloudQualityMetrics& metrics) const;

    /**
     * @brief Export point cloud to PLY format
     * @param pointCloud Input point cloud
     * @param filename Output filename
     * @param config Export configuration
     * @return true if export successful
     */
    bool exportToPLY(const PointCloud& pointCloud,
                    const std::string& filename,
                    const PLYExportConfig& config = {});

    /**
     * @brief Export point cloud to PCD format
     * @param pointCloud Input point cloud
     * @param filename Output filename
     * @param binaryFormat Use binary format (vs ASCII)
     * @return true if export successful
     */
    bool exportToPCD(const PointCloud& pointCloud,
                    const std::string& filename,
                    bool binaryFormat = true);

    /**
     * @brief Export point cloud to OBJ format (vertices only)
     * @param pointCloud Input point cloud
     * @param filename Output filename
     * @return true if export successful
     */
    bool exportToOBJ(const PointCloud& pointCloud,
                    const std::string& filename);

    /**
     * @brief Set progress callback for long operations
     * @param callback Function called with progress (0-100)
     */
    void setProgressCallback(std::function<void(int)> callback);

    /**
     * @brief Get last error message
     * @return Error message string
     */
    std::string getLastError() const;

    /**
     * @brief Get last quality metrics
     * @return Quality metrics from last generation
     */
    PointCloudQualityMetrics getLastMetrics() const;

    /**
     * @brief Enable/disable ARM64 NEON optimizations
     * @param enable Enable ARM64 optimizations
     */
    void enableARM64Optimizations(bool enable = true);

    /**
     * @brief Enable/disable OpenMP parallelization
     * @param enable Enable OpenMP
     * @param numThreads Number of threads (0=auto)
     */
    void enableParallelProcessing(bool enable, int numThreads = 0);

private:
    class Impl;
    std::unique_ptr<Impl> pImpl;

    // Helper methods
    bool validateInputs(const cv::Mat& depthMap, const cv::Mat& colorImage) const;
    bool convertDepthToPoints(const cv::Mat& depthMap,
                             const cv::Mat& colorImage,
                             PointCloud& pointCloud,
                             const PointCloudGenerationConfig& config);
    bool filterDepthMap(cv::Mat& depthMap, const PointCloudGenerationConfig& config);

    void computeBoundingBox(const PointCloud& pointCloud,
                          cv::Vec3f& minBounds,
                          cv::Vec3f& maxBounds,
                          cv::Vec3f& centroid) const;

    double estimateNoiseLevel(const PointCloud& pointCloud) const;
    double estimatePointDensity(const PointCloud& pointCloud,
                               const cv::Vec3f& minBounds,
                               const cv::Vec3f& maxBounds) const;

    // Disable copy
    PointCloudGenerator(const PointCloudGenerator&) = delete;
    PointCloudGenerator& operator=(const PointCloudGenerator&) = delete;
};

} // namespace stereo
} // namespace unlook
