#include "unlook/gui/dataset_capture_widget.hpp"
#include "ui_dataset_capture_widget.h"
#include "unlook/camera/CameraSystem.hpp"
#include "unlook/hardware/AS1170Controller.hpp"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QFormLayout>
#include <QGroupBox>
#include <QMessageBox>
#include <QDir>
#include <QDateTime>
#include <QImage>
#include <QPixmap>
#include <QDebug>
#include <fstream>
#include <opencv2/imgproc.hpp>
#include <opencv2/imgcodecs.hpp>
#include <opencv2/aruco.hpp>

namespace unlook {
namespace gui {

DatasetCaptureWidget::DatasetCaptureWidget(std::shared_ptr<camera::CameraSystem> camera_system, QWidget* parent)
    : QWidget(parent)
    , ui(new Ui::DatasetCaptureWidget)
    , cameraSystem_(camera_system)
    , isCapturing_(false)
    , previewActive_(false)
    , captureCount_(0)
    , targetCaptures_(50)
{
    // Get LED controller singleton instance (same as camera_preview_widget)
    ledController_ = hardware::AS1170Controller::getInstance();

    // Setup UI from .ui file
    setupUi();

    // Setup signal/slot connections
    setupConnections();

    // Initialize pattern detector with default config
    calibration::PatternConfig defaultConfig;
    patternDetector_ = std::make_unique<calibration::PatternDetector>(defaultConfig);

    // Initialize capture timer (not started yet)
    captureTimer_ = new QTimer(this);
    captureTimer_->setSingleShot(false);
    captureTimer_->setInterval(5000);  // 5 seconds between captures
    connect(captureTimer_, &QTimer::timeout, this, &DatasetCaptureWidget::onCaptureFrame);

    // Set ChArUco as default
    patternTypeCombo_->setCurrentIndex(1);

    // Start camera preview using callback system (same as camera_preview_widget)
    startPreviewCapture();
}

DatasetCaptureWidget::~DatasetCaptureWidget() {
    if (isCapturing_) {
        captureTimer_->stop();
        ledController_->setLEDState(hardware::AS1170Controller::LEDChannel::LED1, false, 0);
    }
    delete ui;
}

void DatasetCaptureWidget::setupUi() {
    // Load UI from .ui file
    ui->setupUi(this);

    // Set pointers to widgets from UI
    leftPreview_ = ui->left_preview;
    rightPreview_ = ui->right_preview;
    patternOverlayLeft_ = ui->pattern_overlay_left;
    patternOverlayRight_ = ui->pattern_overlay_right;

    // Pattern configuration controls
    patternTypeCombo_ = ui->pattern_type_combo;
    arucoDictCombo_ = ui->aruco_dict_combo;
    rowsSpinBox_ = ui->rows_spinbox;
    colsSpinBox_ = ui->cols_spinbox;
    squareSizeSpinBox_ = ui->square_size_spinbox;
    arucoSizeSpinBox_ = ui->aruco_size_spinbox;

    // Capture controls
    startCaptureButton_ = ui->start_capture_button;
    captureProgress_ = ui->capture_progress;
    statusLabel_ = ui->status_label;
    detectionStatusLabel_ = ui->detection_status_label;

    // Set default ArUco dictionary to DICT_4X4_250 (index 2)
    arucoDictCombo_->setCurrentIndex(2);
}

void DatasetCaptureWidget::setupConnections() {
    // Pattern type cycle buttons
    connect(ui->pattern_prev_button, &QPushButton::clicked, [this]() {
        int idx = patternTypeCombo_->currentIndex();
        patternTypeCombo_->setCurrentIndex((idx - 1 + patternTypeCombo_->count()) % patternTypeCombo_->count());
    });
    connect(ui->pattern_next_button, &QPushButton::clicked, [this]() {
        int idx = patternTypeCombo_->currentIndex();
        patternTypeCombo_->setCurrentIndex((idx + 1) % patternTypeCombo_->count());
    });
    connect(patternTypeCombo_, QOverload<int>::of(&QComboBox::currentIndexChanged),
            this, &DatasetCaptureWidget::onPatternTypeChanged);

    // ArUco dictionary cycle buttons
    connect(ui->dict_prev_button, &QPushButton::clicked, [this]() {
        int idx = arucoDictCombo_->currentIndex();
        arucoDictCombo_->setCurrentIndex((idx - 1 + arucoDictCombo_->count()) % arucoDictCombo_->count());
    });
    connect(ui->dict_next_button, &QPushButton::clicked, [this]() {
        int idx = arucoDictCombo_->currentIndex();
        arucoDictCombo_->setCurrentIndex((idx + 1) % arucoDictCombo_->count());
    });
    connect(arucoDictCombo_, QOverload<int>::of(&QComboBox::currentIndexChanged),
            this, &DatasetCaptureWidget::onArucoDictChanged);

    // Rows +/- buttons
    connect(ui->rows_minus_button, &QPushButton::clicked, [this]() {
        rowsSpinBox_->setValue(rowsSpinBox_->value() - 1);
    });
    connect(ui->rows_plus_button, &QPushButton::clicked, [this]() {
        rowsSpinBox_->setValue(rowsSpinBox_->value() + 1);
    });

    // Columns +/- buttons
    connect(ui->cols_minus_button, &QPushButton::clicked, [this]() {
        colsSpinBox_->setValue(colsSpinBox_->value() - 1);
    });
    connect(ui->cols_plus_button, &QPushButton::clicked, [this]() {
        colsSpinBox_->setValue(colsSpinBox_->value() + 1);
    });

    // Square size +/- buttons
    connect(ui->square_minus_button, &QPushButton::clicked, [this]() {
        squareSizeSpinBox_->setValue(squareSizeSpinBox_->value() - squareSizeSpinBox_->singleStep());
    });
    connect(ui->square_plus_button, &QPushButton::clicked, [this]() {
        squareSizeSpinBox_->setValue(squareSizeSpinBox_->value() + squareSizeSpinBox_->singleStep());
    });

    // ArUco size +/- buttons
    connect(ui->aruco_minus_button, &QPushButton::clicked, [this]() {
        arucoSizeSpinBox_->setValue(arucoSizeSpinBox_->value() - arucoSizeSpinBox_->singleStep());
    });
    connect(ui->aruco_plus_button, &QPushButton::clicked, [this]() {
        arucoSizeSpinBox_->setValue(arucoSizeSpinBox_->value() + arucoSizeSpinBox_->singleStep());
    });

    // Start capture button
    connect(startCaptureButton_, &QPushButton::clicked, this, &DatasetCaptureWidget::onStartCapture);
}

// Start camera preview using callback system (same as camera_preview_widget)
void DatasetCaptureWidget::startPreviewCapture() {
    if (!cameraSystem_ || previewActive_) return;

    qDebug() << "[DatasetCapture] Starting camera preview capture...";

    // Set frame callback for preview (same system as camera_preview_widget)
    auto frame_callback = [this](const core::StereoFramePair& frame_pair) {
        // Use QMetaObject::invokeMethod for thread-safe GUI updates
        QMetaObject::invokeMethod(this, [this, frame_pair]() {
            updatePreview(frame_pair);
        }, Qt::QueuedConnection);
    };

    if (cameraSystem_->startCapture(frame_callback)) {
        previewActive_ = true;
        qDebug() << "[DatasetCapture] Successfully started camera preview";
    } else {
        qDebug() << "[DatasetCapture] Failed to start camera preview";
    }
}

// Stop camera preview
void DatasetCaptureWidget::stopPreviewCapture() {
    if (!previewActive_) return;

    qDebug() << "[DatasetCapture] Switching to background capture mode";

    // Create background callback to keep cameras running
    auto background_callback = [](const core::StereoFramePair& /*frame_pair*/) {
        // Frame received but not processed
    };

    cameraSystem_->startCapture(background_callback);
    previewActive_ = false;
}

// Update preview from camera callback (same as camera_preview_widget)
void DatasetCaptureWidget::updatePreview(const core::StereoFramePair& frame_pair) {
    if (!previewActive_) return;

    // Save latest frame for capture (thread-safe)
    {
        std::lock_guard<std::mutex> lock(latestFrameMutex_);
        latestFramePair_ = frame_pair;
    }

    // Frame skipping for performance (process every 3rd frame like camera_preview_widget)
    static int frame_skip_counter = 0;
    if (++frame_skip_counter % 3 != 0) {
        return;
    }

    // Extract frames (already in BGRA format from core::CameraFrame)
    cv::Mat leftRGB, rightRGB;
    cv::cvtColor(frame_pair.left_frame.image, leftRGB, cv::COLOR_BGRA2RGB);
    cv::cvtColor(frame_pair.right_frame.image, rightRGB, cv::COLOR_BGRA2RGB);

    // Downsample to HD 1280x720
    cv::Mat leftHD, rightHD;
    cv::resize(leftRGB, leftHD, cv::Size(1280, 720), 0, 0, cv::INTER_AREA);
    cv::resize(rightRGB, rightHD, cv::Size(1280, 720), 0, 0, cv::INTER_AREA);

    // Detect pattern and draw overlay (thread-safe)
    std::vector<cv::Point2f> cornersLeft, cornersRight;
    cv::Mat overlayLeft, overlayRight;

    bool leftDetected, rightDetected;
    {
        std::lock_guard<std::mutex> lock(patternDetectorMutex_);
        if (patternDetector_) {
            leftDetected = patternDetector_->detect(leftHD, cornersLeft, overlayLeft);
            rightDetected = patternDetector_->detect(rightHD, cornersRight, overlayRight);
        } else {
            leftDetected = false;
            rightDetected = false;
        }
    }

    // Update detection status
    if (leftDetected && rightDetected) {
        detectionStatusLabel_->setText("✓ Pattern Detected");
        detectionStatusLabel_->setStyleSheet("font-size: 12pt; color: #00FF00; font-weight: bold;");
        patternOverlayLeft_->setText(QString("✓ Detected: %1 corners").arg(cornersLeft.size()));
        patternOverlayLeft_->setStyleSheet("font-size: 11pt; color: #00FF00;");
        patternOverlayRight_->setText(QString("✓ Detected: %1 corners").arg(cornersRight.size()));
        patternOverlayRight_->setStyleSheet("font-size: 11pt; color: #00FF00;");
    } else {
        detectionStatusLabel_->setText("✗ Pattern Not Detected");
        detectionStatusLabel_->setStyleSheet("font-size: 12pt; color: #FF0000; font-weight: bold;");
        patternOverlayLeft_->setText(leftDetected ? "✓ Detected" : "✗ Not detected");
        patternOverlayLeft_->setStyleSheet(leftDetected ? "font-size: 11pt; color: #00FF00;" : "font-size: 11pt; color: #FF0000;");
        patternOverlayRight_->setText(rightDetected ? "✓ Detected" : "✗ Not detected");
        patternOverlayRight_->setStyleSheet(rightDetected ? "font-size: 11pt; color: #00FF00;" : "font-size: 11pt; color: #FF0000;");
    }

    // Convert to QPixmap and display (with deep copy for safety)
    if (!overlayLeft.empty()) {
        QImage qimgLeft(overlayLeft.data, overlayLeft.cols, overlayLeft.rows,
                       overlayLeft.step, QImage::Format_RGB888);
        QImage qimgLeftCopy = qimgLeft.copy();  // Deep copy for safety
        leftPreview_->setPixmap(QPixmap::fromImage(qimgLeftCopy));
    }

    if (!overlayRight.empty()) {
        QImage qimgRight(overlayRight.data, overlayRight.cols, overlayRight.rows,
                        overlayRight.step, QImage::Format_RGB888);
        QImage qimgRightCopy = qimgRight.copy();  // Deep copy for safety
        rightPreview_->setPixmap(QPixmap::fromImage(qimgRightCopy));
    }
}

void DatasetCaptureWidget::onStartCapture() {
    if (isCapturing_) {
        // Stop capture
        captureTimer_->stop();
        isCapturing_ = false;
        startCaptureButton_->setText("Start Dataset Capture (50 pairs)");
        startCaptureButton_->setStyleSheet(
            "QPushButton { background-color: #059669; color: white; font-size: 14pt; "
            "padding: 12px; border-radius: 8px; font-weight: bold; }");
        statusLabel_->setText("Capture stopped");

        // Disable both LEDs (ensure both are OFF)
        if (ledController_) {
            bool led1_off = ledController_->setLEDState(hardware::AS1170Controller::LEDChannel::LED1, false, 0);
            bool led2_off = ledController_->setLEDState(hardware::AS1170Controller::LEDChannel::LED2, false, 0);

            if (led1_off) {
                qDebug() << "[DatasetCapture] LED1 (VCSEL) disabled";
            }
            if (led2_off) {
                qDebug() << "[DatasetCapture] LED2 (Flood) disabled";
            }
        }
        return;
    }

    // Create dataset directory
    QString timestamp = QDateTime::currentDateTime().toString("yyyyMMdd_HHmmss");
    currentDatasetPath_ = "/unlook_calib_dataset/dataset_" + timestamp;

    QDir().mkpath(currentDatasetPath_ + "/left");
    QDir().mkpath(currentDatasetPath_ + "/right");

    // Initialize dataset info JSON
    datasetInfo_["dataset_info"]["timestamp"] = timestamp.toStdString();
    datasetInfo_["dataset_info"]["creation_date"] =
        QDateTime::currentDateTime().toString(Qt::ISODate).toStdString();
    datasetInfo_["dataset_info"]["dataset_path"] = currentDatasetPath_.toStdString();

    // Pattern config
    datasetInfo_["pattern_config"]["type"] = patternTypeCombo_->currentText().toStdString();
    datasetInfo_["pattern_config"]["rows"] = rowsSpinBox_->value();
    datasetInfo_["pattern_config"]["cols"] = colsSpinBox_->value();
    datasetInfo_["pattern_config"]["square_size_mm"] = squareSizeSpinBox_->value();
    datasetInfo_["pattern_config"]["aruco_marker_size_mm"] = arucoSizeSpinBox_->value();

    // Capture config
    datasetInfo_["capture_config"]["image_width"] = 1280;
    datasetInfo_["capture_config"]["image_height"] = 720;
    datasetInfo_["capture_config"]["capture_delay_seconds"] = 5;
    datasetInfo_["capture_config"]["target_image_pairs"] = 50;
    datasetInfo_["capture_config"]["vcsel_enabled"] = true;
    datasetInfo_["capture_config"]["vcsel_current_ma"] = 280;

    // Initialize and enable VCSEL LED (LED1 only, >= 250mA)
    if (ledController_) {
        // Initialize if not already done (same as camera_preview_widget)
        if (!ledController_->isInitialized()) {
            qDebug() << "[DatasetCapture] Initializing AS1170 controller";

            // CRITICAL: Force reset hardware BEFORE initialization
            qDebug() << "[DatasetCapture] Forcing AS1170 hardware reset to clear stuck state";
            ledController_->forceResetHardware();

            if (!ledController_->initialize()) {
                qWarning() << "[DatasetCapture] Failed to initialize AS1170 controller - LEDs will not work";
                statusLabel_->setText("WARNING: LED controller initialization failed");
            } else {
                qDebug() << "[DatasetCapture] AS1170 controller initialized successfully";
            }
        }

        // Enable LED1 (VCSEL) at 280mA (>= 250mA minimum requirement)
        bool led1_success = ledController_->setLEDState(hardware::AS1170Controller::LEDChannel::LED1, true, 280);

        // Ensure LED2 is OFF (user requirement: LED1 ON, LED2 OFF)
        bool led2_success = ledController_->setLEDState(hardware::AS1170Controller::LEDChannel::LED2, false, 0);

        if (led1_success) {
            qDebug() << "[DatasetCapture] LED1 (VCSEL) activated at 280mA";
        } else {
            qWarning() << "[DatasetCapture] Failed to activate LED1 (VCSEL)";
        }

        if (led2_success) {
            qDebug() << "[DatasetCapture] LED2 (Flood) disabled";
        } else {
            qWarning() << "[DatasetCapture] Failed to disable LED2";
        }
    }

    // Start capture
    captureCount_ = 0;
    targetCaptures_ = 50;
    isCapturing_ = true;

    startCaptureButton_->setText("Stop Capture");
    startCaptureButton_->setStyleSheet(
        "QPushButton { background-color: #dc2626; color: white; font-size: 14pt; "
        "padding: 12px; border-radius: 8px; font-weight: bold; }");
    statusLabel_->setText("Capturing... move checkerboard between captures");

    captureTimer_->start();

    // Capture first frame immediately
    onCaptureFrame();
}

void DatasetCaptureWidget::onCaptureFrame() {
    if (captureCount_ >= targetCaptures_) {
        // Capture complete
        captureTimer_->stop();
        isCapturing_ = false;

        // Disable both LEDs (ensure both are OFF)
        if (ledController_) {
            bool led1_off = ledController_->setLEDState(hardware::AS1170Controller::LEDChannel::LED1, false, 0);
            bool led2_off = ledController_->setLEDState(hardware::AS1170Controller::LEDChannel::LED2, false, 0);

            if (led1_off) {
                qDebug() << "[DatasetCapture] LED1 (VCSEL) disabled after completion";
            }
            if (led2_off) {
                qDebug() << "[DatasetCapture] LED2 (Flood) disabled after completion";
            }
        }

        // Save dataset info
        saveDatasetInfo();

        startCaptureButton_->setText("Start Dataset Capture (50 pairs)");
        startCaptureButton_->setStyleSheet(
            "QPushButton { background-color: #059669; color: white; font-size: 14pt; "
            "padding: 12px; border-radius: 8px; font-weight: bold; }");
        statusLabel_->setText("Dataset capture complete!");

        QMessageBox::information(this, "Capture Complete",
            "Dataset saved to:\n" + currentDatasetPath_ +
            "\n\nProceed to Processing tab to calibrate.");

        emit datasetCaptureCompleted(currentDatasetPath_);
        return;
    }

    // Capture and save frame pair
    captureAndSaveFrame();
    captureCount_++;
    captureProgress_->setValue(captureCount_);

    statusLabel_->setText(QString("Captured %1 / %2 pairs - move checkerboard for next capture")
                         .arg(captureCount_).arg(targetCaptures_));
}

void DatasetCaptureWidget::captureAndSaveFrame() {
    // Get latest frame from preview callback (thread-safe)
    core::StereoFramePair framePair;
    {
        std::lock_guard<std::mutex> lock(latestFrameMutex_);
        if (latestFramePair_.left_frame.image.empty() || latestFramePair_.right_frame.image.empty()) {
            qCritical() << "CRITICAL: No frame available for capture";
            return;
        }
        framePair = latestFramePair_;
    }

    // Extract frames (already in BGRA format)
    cv::Mat leftFrame = framePair.left_frame.image.clone();
    cv::Mat rightFrame = framePair.right_frame.image.clone();

    // Log sync quality (timestamp_ns is in nanoseconds, convert to milliseconds)
    double syncErrorMs = std::abs(static_cast<double>(framePair.left_frame.timestamp_ns) -
                                   static_cast<double>(framePair.right_frame.timestamp_ns)) / 1000000.0;
    if (syncErrorMs > 1.0) {
        qWarning() << "Frame" << captureCount_ << "sync error:" << syncErrorMs << "ms";
    }

    // Downsample to HD
    cv::Mat leftHD, rightHD;
    cv::resize(leftFrame, leftHD, cv::Size(1280, 720), 0, 0, cv::INTER_AREA);
    cv::resize(rightFrame, rightHD, cv::Size(1280, 720), 0, 0, cv::INTER_AREA);

    // Save images
    QString leftPath = currentDatasetPath_ + "/left/frame_" +
                      QString::number(captureCount_).rightJustified(3, '0') + ".png";
    QString rightPath = currentDatasetPath_ + "/right/frame_" +
                       QString::number(captureCount_).rightJustified(3, '0') + ".png";

    cv::imwrite(leftPath.toStdString(), leftHD);
    cv::imwrite(rightPath.toStdString(), rightHD);

    // Detect pattern for quality info (thread-safe)
    std::vector<cv::Point2f> cornersLeft, cornersRight;
    cv::Mat dummy;
    bool leftDetected, rightDetected;
    float qualityScore = 0.0f;
    {
        std::lock_guard<std::mutex> lock(patternDetectorMutex_);
        if (patternDetector_) {
            leftDetected = patternDetector_->detect(leftHD, cornersLeft, dummy);
            rightDetected = patternDetector_->detect(rightHD, cornersRight, dummy);
            qualityScore = (leftDetected && rightDetected) ?
                patternDetector_->getConfidenceScore() : 0.0f;
        } else {
            leftDetected = false;
            rightDetected = false;
            qualityScore = 0.0f;
        }
    }

    // Add to dataset info JSON with sync metadata
    nlohmann::json pairInfo;
    pairInfo["index"] = captureCount_;
    pairInfo["left_filename"] = ("left/frame_" +
        QString::number(captureCount_).rightJustified(3, '0') + ".png").toStdString();
    pairInfo["right_filename"] = ("right/frame_" +
        QString::number(captureCount_).rightJustified(3, '0') + ".png").toStdString();
    pairInfo["timestamp"] = QDateTime::currentDateTime().toString(Qt::ISODate).toStdString();
    pairInfo["corners_detected_left"] = cornersLeft.size();
    pairInfo["corners_detected_right"] = cornersRight.size();
    pairInfo["quality_score"] = qualityScore;

    // Add hardware sync metadata for validation
    pairInfo["sync_error_ms"] = syncErrorMs;
    pairInfo["is_synchronized"] = (syncErrorMs < 1.0);
    pairInfo["left_timestamp_ns"] = framePair.left_frame.timestamp_ns;
    pairInfo["right_timestamp_ns"] = framePair.right_frame.timestamp_ns;

    datasetInfo_["image_pairs"].push_back(pairInfo);
}

void DatasetCaptureWidget::saveDatasetInfo() {
    QString jsonPath = currentDatasetPath_ + "/dataset_info.json";
    std::ofstream file(jsonPath.toStdString());

    if (!file.is_open()) {
        qCritical() << "Failed to open dataset info file for writing:" << jsonPath;
        QMessageBox::critical(this, "Save Error",
            "Failed to save dataset info file:\n" + jsonPath +
            "\n\nCheck disk space and permissions.");
        return;
    }

    file << datasetInfo_.dump(2);  // Pretty print with 2-space indent

    if (!file.good()) {
        qCritical() << "Write error for dataset info file:" << jsonPath;
        QMessageBox::critical(this, "Save Error",
            "Write error for dataset info file:\n" + jsonPath +
            "\n\nDisk may be full or I/O error occurred.");
        file.close();
        return;
    }

    file.close();

    if (!file.good()) {
        qCritical() << "Error closing dataset info file:" << jsonPath;
    }
}

void DatasetCaptureWidget::onPatternTypeChanged(int index) {
    updatePatternDetector();
}

void DatasetCaptureWidget::onArucoDictChanged(int index) {
    qDebug() << "ArUco dictionary changed to index:" << index;
    updatePatternDetector();
}

void DatasetCaptureWidget::updatePatternDetector() {
    calibration::PatternConfig config;
    config.type = static_cast<calibration::PatternType>(
        patternTypeCombo_->currentData().toInt());
    config.rows = rowsSpinBox_->value();
    config.cols = colsSpinBox_->value();
    config.squareSizeMM = squareSizeSpinBox_->value();
    config.arucoMarkerSizeMM = arucoSizeSpinBox_->value();

    // Map combo box index to ArUco dictionary enum
    const std::vector<cv::aruco::PREDEFINED_DICTIONARY_NAME> dictMap = {
        cv::aruco::DICT_4X4_50,
        cv::aruco::DICT_4X4_100,
        cv::aruco::DICT_4X4_250,
        cv::aruco::DICT_4X4_1000,
        cv::aruco::DICT_5X5_50,
        cv::aruco::DICT_5X5_100,
        cv::aruco::DICT_5X5_250,
        cv::aruco::DICT_5X5_1000,
        cv::aruco::DICT_6X6_50,
        cv::aruco::DICT_6X6_100,
        cv::aruco::DICT_6X6_250,
        cv::aruco::DICT_6X6_1000,
        cv::aruco::DICT_7X7_50,
        cv::aruco::DICT_7X7_100,
        cv::aruco::DICT_7X7_250,
        cv::aruco::DICT_7X7_1000,
        cv::aruco::DICT_ARUCO_ORIGINAL
    };

    int dictIndex = arucoDictCombo_->currentIndex();
    if (dictIndex >= 0 && dictIndex < static_cast<int>(dictMap.size())) {
        config.arucoDict = dictMap[dictIndex];
        qDebug() << "Using ArUco dictionary:" << arucoDictCombo_->currentText();
    } else {
        config.arucoDict = cv::aruco::DICT_4X4_250;  // Default fallback
    }

    // Thread-safe pattern detector recreation
    std::lock_guard<std::mutex> lock(patternDetectorMutex_);
    patternDetector_ = std::make_unique<calibration::PatternDetector>(config);
}


} // namespace gui
} // namespace unlook
